tomer.levi,nitzan.daloomy
323961854,212071914

one of the regex patterns we use in the code is called VARIABLE_DECLARATION_LINE, which is the following:

"^\s*(?:(final)\s+)?(int|double|String|boolean|char)\s+((?:\b(?:[a-zA-Z]\w*|_[a-zA-Z0-9]\w*)
\b\s*=\s*(?:"[^"]*"|'[^']'|true|false|[+\-]?(?:\d+\.?\d*|\.\d+)|[+\-]?\d+|\b(?:[a-zA-Z]\w*|_[a-zA-Z0-9]\w*)
\b)|\b(?:[a-zA-Z]\w*|_[a-zA-Z0-9]\w*)\b)(?:\s*,\s*(?:\b(?:[a-zA-Z]\w*|_[a-zA-Z0-9]\w*)\b\s*=\s*
(?:"[^"]*"|'[^']'|true|false|[+\-]?(?:\d+\.?\d*|\.\d+)|[+\-]?\d+|\b(?:[a-zA-Z]\w*|_[a-zA-Z0-9]\w*)\b)
|\b(?:[a-zA-Z]\w*|_[a-zA-Z0-9]\w*)\b))*)\s*;\s*$"

This pattern validates the whole structure of a variable declaration.
To break it down:
There are 3 capturing groups in this RegEx statement:
    Group 1 captures whether the variable is final or not (captures final if it is, null if not)
    Group 2 captures the variable's type
    Group 3 captures the content of the variables' definitions - later to be validated
And here are the parts constructing it:
    SPACES_INITIAL:
        RegEx statement:
            ^\s*
        Purpose:
            Dealing with any spaces initial, which is defined as legal when referring to a
            variables' declaration.

    FINAL:
        RegEx statement:
            final
        Purpose:
            Referring to the optional keyword "final" existence.
            If it's found (and captured), the declared variables are all initialized as final, and
            must have an initial value.

    SPACE_CHAR:
        RegEx statement:
            \s
        Purpose:
            Used anywhere we want to enable spaces, followed by + or * to specify the amount we're
            "allowing".

    VARIABLES_DECLARATION_CONTENT:
        RegEx statement:
            (?:\b(?:[a-zA-Z]\w*|_[a-zA-Z0-9]\w*)\b\s*=\s*(?:"[^"]*"|'[^']'|true|false|[+\-]?
            (?:\d+\.?\d*|\.\d+)|[+\-]?\d+|\b(?:[a-zA-Z]\w*|_[a-zA-Z0-9]\w*)\b)|\b
            (?:[a-zA-Z]\w*|_[a-zA-Z0-9]\w*)\b)(?:\s*,\s*(?:\b(?:[a-zA-Z]\w*|_[a-zA-Z0-9]\w*)
            \b\s*=\s*(?:"[^"]*"|'[^']'|true|false|[+\-]?(?:\d+\.?\d*|\.\d+)|[+\-]?\d+|\b
            (?:[a-zA-Z]\w*|_[a-zA-Z0-9]\w*)\b)|\b(?:[a-zA-Z]\w*|_[a-zA-Z0-9]\w*)\b))*
        Purpose:
            Dealing with the content of the declaration, meaning anything that comes after
            the optional final keyword and the type and before the line-ending semicolon
            (i.e. "a, b=5, c").



    ENDING_SEMICOLON:
        RegEx statement:
            \\s*;\\s*$
        Purpose:
            Making sure the line ends with a semicolon, padded with optional spaces.

the second regex pattern we use is called METHOD_PATTERN
"^\\s*void\\s+(\\b[a-zA-Z]\\w*\\b)\\s*\\(([^)]*)\\)\\s*\\{"
the pattern validates the whole structure of a method declaration
to break it down:
Group 1 captures the method's return type (void)
Group 2 captures the method's name
Group 3 captures the method's parameters
And here are the parts constructing it:
SPACES_INITIAL:
    RegEx statement:
        ^\s*
    Purpose:
        Dealing with any spaces initial, which is defined as legal when referring to a method's
        declaration.

"void"
    the method's return type which must always be void.
    This is followed by at least one space SPACE_CHAR as specified above.

METHOD_NAME:
    RegEx statement:
        (\\b[a-zA-Z]\\w*\\b)
    Purpose:
        finding the method name. followed by at least one space SPACE_CHAR as specified above.

the RegEx expression "([^)(]*)\\)" :
    gets all the parameters of the method, separated by commas.
    the parameters are captured in Group 3.

followed by the RegEx expression "\\{" :
    defines the beginning of the method body. this must follow the method declaration and the parameters.

we have more patterns for if\while\comment lines.

the structure of out code is as follows:
Scope - this is the class responsible for holding all the variables and methods,
it uses the LineReader class to classify the lines as comments, variables, methods, etc.
then act accordingly, throw an exception or add the variable\method to the Scope, etc.
LineReader - this class reads the file line by line and classifies it as a comment, variable, method, etc.
Variable - this class represents a variable, it has a name, type, and value
Method - this class represents a method, it has a name, parameters, and body and self validating methods.
IfWhile - this class represents an if\while statement, it has a condition and a body and self validating methods.
Utils - all of the utils are in the form of a static class, meaning all the methods are static and can be called from anywhere.
this is because instantiating a class like this is meaningless,
as we only use the methods on information from different classes, and we never require more than one of each util.
the utils vary from class to class, some classes have more self validating methods in the utils.
some have extract methods to get the variable\method name\type\body\condition to be used in other classes for validation.
but we only ever use the methods.
reg_ex_patterns - this holds all the regex patterns we use in the code.
they are all public to be used in the code, as they are static, and we never change them.
instead of defining the same pattern in different places, we reuse the same constant patterns.
Main - specifically SJava, this is the main class, it reads the file and calls the Scope class to validate it.
the main (not the Sjava class) is also where we keep the type 2 exceptions.
the IllegalException is thrown throughout the entire code, so it is not kept in a single module or class.